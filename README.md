# Resumen
Se está tratando de generar con IA documentación a partir de código del proyecto Essh.

Para hacer un primer overview e interpretar la estructura de archivos y la posible arquitectura del proyecto se ha hecho en Cherry Studio usando llama-versatile-70b, y el mcp de FileSys incluido en Cherry Studio, así como un análisis previo de los posibles archivos más importantes y sus partes destacables (essh.go, task.go y host.go).

Con la documentación generada de esta primera iteración se ha creado una pequeña knowledge base, que ha sido usada por claude 3.5 en VSCode para interpretar las partes críticas del código y generar una documentación un poco más extensa.

# Prompts/Proceso
Aquí se detallarán los prompts usados para la generación de este documento, intentando mostrar su estructura más allá de un ejemplo concreto, el resultado que se espera obtener y posibles observaciones.

### Llama
Aquí se trata de hacer una documentación previa de la estructura, arquitectura y funcionalidad del proyecto, con el fín de usarlo más adelante como apoyo. No es raro en esta fase tener que modificar ligeramente algún prompt para que incluya o excluya partes según nuestro criterio. Para un mejor entendimiento escribiré los prompts en español, aunque lo normal sería preguntar en inglés.

0. Como paso previo a la generación de documentación se le ha pedido a la IA que sintetice la documentación ya existente, con el fin de usarlo como apoyo a la hora de empezar a generar, este primer prompt sería algo así: ```Sintetiza la información de esta página sobre la documentación de un proyecto en golang [URL] presta especial atención a [puntos destacables]. Crea un .md con la información``` en este caso la URL es la documentación de Essh (https://sevir.github.io/essh/docs/en/index.html) y los puntos destacables son las partes que queremos evitar que la IA pueda excluir, en lugar de decirle "presta especial atención" podemos decirle "incluye", si es bastante crítico, en este caso no tenía una parte tan clara, así que los puntos destacables fueron host, task, drivers, group y configuration files.

1. Ahora le pediremos que trate de analizar la estructura del proyecto, para esto se ha utilizado un MCP de sistema de ficheros, la idea es utilizar la herramienta de list_tree para que liste todos los directorios y ficheros desde la raíz del proyecto, de esta forma puede interpretar y tratar de dar una aproximación de la estructura que sigue, también se le pedirá destacar archivos que crea importantes para el siguiente paso. El prompt quedaría así ```Analiza la estructura del siguiente proyecto en golang, creando un .md con la documentación, distingue sus partes, cómo crees que interactúan entre sí y para que sirve cada una, añade además los archivos concretos que creas más importantes. Utiliza la herramienta list_tree para ver la jerarquía de archivos en [Carpeta raíz]. Apoyate sobre [archivo paso 0] para las cosas que no sean claras``` en este paso queremos que escriba una idea de la arquitectura de la aplicación, la carpeta raíz será la carpeta donde tenemos el proyecto y archivo paso 0 la documentación previamente generada. No buscamos una documentación extremadamente detallada, sino una idea del proyecto. Se le especifica el uso de list_tree para que haga la recursión, al ser tan solo un arbol de directorios y ficheros no tendremos problemas de tokens, mientras que la IA tendrá mejor comprensión de la estructura.

2. Por último en esta fase le pediremos una especie de resumen o puntos clave de los archivos que ha considerado imporantes en el paso anterior, con un prompt similar a ```Analiza el archivo [ruta] y escribe un .md con los recursos externos que utiliza y partes de código imporantes, ten en cuenta que forma parte de la estructura de este proyecto [documentación paso 1]``` este paso se realiza con todos los posibles archivos importantes, queremos concretar un poco más en cómo funcionan, ruta es la ruta del archivo específico y la documentación paso 1 es la interpretación de la arquitectura que se ha hecho anteriormente. Los que más interesa de aquí es identificar los recursos externos que usa cada archivo para usarlo a la hora de documentar código concreto, las partes de código importantes que nos haya dado necesitarán una pequeña revisión y si es necesario se pueden eliminar.

### Claude
Ahora se trata de generar documentación sobre archivos y código concretos, apoyandose todo el rato en la documentación generada con Llama, por lo que estará siempre adjunta o en la knowledge base. Aquí es realmente donde está lo pesado, por eso se ha utilizado VSCode con copilot, por el problema de los tokens.

3. empezamos a crear documentación sobre los archivos con un prompt como ```Revisa la estructura general del programa y lee los archivos principales generando .md por cada uno, utiliza la documentación adjunta para información sobre el proyecto``` Esta primera generación apunta a empezar a crear documentación concreta, como nos liberamos de los tokens se le ha pedido que revise todos los archivos principales y documentación creada a la vez para que genere documentación con un entendimiento amplio del proyecto. Los archivos importante y que debería actualizar están en la documentación aportada, pero si se quieren concretar no está de más.

4. Le pedimos que profundice en los archivos creados ```Profundiza más en los archivos creados, relee los archivos y escribe código concreto con comentarios explicativos. Trabaja sobre lo creado anteriormente y actualízalo``` La intención es que se centre en los archivos que ya ha creado teniendo todo el entendimiento general y concrete sobre ellos con ejemplos y partes del código concretas. No sería descabellado pedirle esto archivo a archivo en lugar de todo a la vez. Es posible que aquí haya que hacer varias iteraciones, regenerando la respuesta y haciendo algún cambio al prompt según qúe cosas nos vaya dando o si detectamos un proceso de pensamiento erroneo.

4.1. Se le puede pedir que con esta nueva documentación haga otra revisión de la estrucatura general del proyecto (el overview) para tratar de que sea todo lo veraz posible. Si hay cambios sustanciales, se debería repetir el paso 4 con los cambios pertinentes.

5. Por último y tras revisar el paso 4 se le pide documentación de otros archivos, si se tiene alguno concreto en mente se debería especificar, si no, podemos dejar que interprete él mismo. ```Con la documentación que has generado y la estructura del proyecto genera documentación sobre otros archivos que consideres imporantes para el proyecto``` Con lo generado se puede seguir el paso 4 de nuevo, para ahondar más. De este paso no estoy completamente seguro, se hace después de haber analizado la estructura y generado la documentación imporante, temo que pueda alucinar demasiado, de todas formas parece que este no ha sido el caso.


Además de seguir los pasos y utilizar los prompts que se han detallado aquí habrá que ir haciendo pequeñas modificiones según nuestro criterio para que la documentación generada sea en todo momento lo más fiable. Específicamente se le tendrá que pedir que no alucine, con conceptos concretos a ser posible, y explicarle cosas del proyecto que haya podido entender mal.
